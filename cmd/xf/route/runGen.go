package route

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func generateRunFunctionStr(fileName string) string {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return ""
	}

	var handlerFuncName string
	var fn *ast.FuncDecl
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == "handler" && len(funcDecl.Type.Params.List) >= 2 {
			handlerFuncName = funcDecl.Name.Name
			fn = funcDecl
			break
		}
	}

	if handlerFuncName == "" {
		return ""
	}

	// 提取handler的参数列表（去掉前两个）
	var params []string
	var paramsTypes []string
	var de []string
	if len(fn.Type.Params.List) > 2 {
		for _, field := range fn.Type.Params.List[2:] {
			for _, name := range field.Names {
				params = append(params, name.Name)
				paramsTypes = append(paramsTypes, getTypeString(field.Type))
				de = append(de, `var `+name.Name+" "+getTypeString(field.Type))
			}
		}
	}

	// 构建Run函数
	runFunc := `
func Run() xhs.Handler {
`
	if len(de) > 0 {
		for _, line := range de {
			runFunc += `	` + line + "\n"
		}
		runFunc += `    xe.MustInvoke(func(`

		// 构造参数列表
		var invokeParams []string
		for i, param := range paramsTypes {
			invokeParams = append(invokeParams, "p"+string(rune(i+'1'))+" "+param)
		}
		runFunc += strings.Join(invokeParams, ", ") + `) {
`
		for i, param := range params {
			runFunc += `        ` + param + ` = p` + string(rune(i+'1')) + `
`
		}
		runFunc += `    })
`
	}

	runFunc += `    return func(c *xhs.Ctx) (interface{}, error) {
        r := request{}
        err := c.ShouldBind(&r)
        if err != nil {
            return nil, xerror.New("参数错误").SetCode(xhs.CodeParamError).SetInfo("参数错误: %+v", err)
        }
`
	runFunc += `        return ` + handlerFuncName + `(c, &r, ` + strings.Join(params, ", ") + `)
    }
}
`
	return runFunc
}

// 辅助函数：从AST节点获取类型字符串
func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.StarExpr:
		// 指针类型
		return "*" + getTypeString(t.X)
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	default:
		return ""
	}
}

// GenerateAndReplaceRunFunction 处理单个文件，直接更新文件内容
func GenerateAndReplaceRunFunction(fileName string) error {
	// 首先读取原始文件内容
	content, err := os.ReadFile(fileName)
	if err != nil {
		return err
	}

	// 解析AST以找到Run函数的位置
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, content, parser.ParseComments)
	if err != nil {
		return err
	}

	// 查找现有的Run函数
	var runFuncStart, runFuncEnd token.Pos
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == "Run" {
			runFuncStart = funcDecl.Pos()
			runFuncEnd = funcDecl.End()
			break
		}
	}

	// 生成新的Run函数
	newRunFunc := generateRunFunctionStr(fileName)
	if newRunFunc == "" {
		return nil // 没有handler函数，跳过
	}

	// 如果找到了现有的Run函数，则删除它
	var updatedContent string
	if runFuncStart != token.NoPos && runFuncEnd != token.NoPos {
		// 将文件内容转换为字符串并删除Run函数部分
		fileContent := string(content)
		startOffset := fset.Position(runFuncStart).Offset
		endOffset := fset.Position(runFuncEnd).Offset

		// 删除Run函数部分
		updatedContent = fileContent[:startOffset] + fileContent[endOffset:]
	} else {
		// 如果没有找到Run函数，则使用原始内容
		updatedContent = string(content)
	}

	// 在文件末尾添加新的Run函数
	finalContent := updatedContent
	// 确保文件以换行符结尾
	if !strings.HasSuffix(finalContent, "\n") {
		finalContent += "\n"
	}

	finalContent += "\n" + newRunFunc

	// 获取文件所在目录
	dir := filepath.Dir(fileName)

	// 构造run.go文件路径
	runFileName := filepath.Join(dir, "run.go")

	// 如果文件已存在，则删除它
	if _, err := os.Stat(runFileName); !os.IsNotExist(err) {
		err := os.Remove(runFileName)
		if err != nil {
			return err
		}
	}

	// 解析包名
	f, err = parser.ParseFile(fset, fileName, content, parser.PackageClauseOnly)
	if err != nil {
		return err
	}

	// 构造完整的文件内容
	fileContent := "// Code generated by xf. Do not modify it except for dependency, as it will be overwritten.\n\n"
	fileContent += "package " + f.Name.Name + "\n\n"
	fileContent += newRunFunc

	// 写入run.go文件
	return os.WriteFile(runFileName, []byte(fileContent), 0644)
}

// ScanAndGenerateRunFunctions 扫描文件夹下所有.go文件并生成Run函数
func ScanAndGenerateRunFunctions(dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 只处理.go文件，排除目录和非.go文件
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			// 检查文件是否包含handler函数
			if hasHandlerFunction(path) {
				err := GenerateAndReplaceRunFunction(path)
				if err != nil {
					return err
				}
			}
		}

		return nil
	})
}

// hasHandlerFunction 检查文件是否包含handler函数
func hasHandlerFunction(fileName string) bool {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return false
	}

	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == "handler" {
			// 检查参数数量，确保至少有2个参数(c和r)
			if len(funcDecl.Type.Params.List) >= 2 {
				return true
			}
		}
	}

	return false
}
