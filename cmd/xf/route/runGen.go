package route

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/77d88/go-kit/basic/xarray"
	"github.com/77d88/go-kit/basic/xstr"
)

const runFileHeader = "// Code generated by xf. DO NOT EDIT.\n\n"

func generateRunFunctionStr(fileName string) (string, []string, []string) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return "", nil, nil
	}

	b, fn, handlerFuncName := checkHandler(f)
	if !b {
		return "", nil, nil
	}

	// 提取handler的参数列表（去掉前两个）
	var params []string
	var paramsTypes []string
	var de []string
	if len(fn.Type.Params.List) > 2 {
		for _, field := range fn.Type.Params.List[2:] {
			for _, name := range field.Names {
				params = append(params, name.Name)
				paramsTypes = append(paramsTypes, getTypeString(field.Type))
				de = append(de, `var `+name.Name+" "+getTypeString(field.Type))
			}
		}
	}

	// 构建Run函数
	runFunc := `func run() xhs.Handler {
`
	if len(de) > 0 {
		for _, line := range de {
			runFunc += `	` + line + "\n"
		}
		runFunc += `    err := x.Find(func(`

		// 构造参数列表
		var invokeParams []string
		for i, param := range paramsTypes {
			invokeParams = append(invokeParams, "p"+string(rune(i+'1'))+" "+param)
		}
		runFunc += strings.Join(invokeParams, ", ") + `) {
`
		for i, param := range params {
			runFunc += `        ` + param + ` = p` + string(rune(i+'1')) + `
`
		}
		runFunc += `    })
`
		runFunc += `	if err != nil {
		panic(err)
	}
`
	}

	runFunc += `    return func(c *xhs.Ctx) (interface{}, error) {
        r := request{}
        err := c.ShouldBind(&r)
        if err != nil {
            return nil, xerror.New("参数错误").SetCode(xhs.CodeParamError).SetInfo("参数错误: %+v", err)
        }
`
	if len(params) > 0 {
		runFunc += `        return ` + handlerFuncName + `(c, &r, ` + strings.Join(params, ", ") + `)
    }
}
`
	} else {
		runFunc += `        return ` + handlerFuncName + `(c, &r)
    }
}
`
	}

	return runFunc, params, paramsTypes
}

// 辅助函数：从AST节点获取类型字符串
func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.StarExpr:
		// 指针类型
		return "*" + getTypeString(t.X)
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	default:
		return ""
	}
}

// GenerateAndReplaceRunFunction 处理单个文件，直接更新文件内容
func GenerateAndReplaceRunFunction(fileName string) error {
	// 获取文件所在目录
	dir := filepath.Dir(fileName)
	// 构造run.go文件路径
	runFileName := filepath.Join(dir, "run.go")

	// 写入run.go文件
	content, err := genRunFileContent(fileName)
	if err != nil {
		return err
	}
	return os.WriteFile(runFileName, []byte(content), 0644)
}

func genRunFileContent(fileName string) (string, error) {
	// 首先读取原始文件内容
	content, err := os.ReadFile(fileName)
	if err != nil {
		return "", err
	}
	// 解析AST以找到Run函数的位置
	fset := token.NewFileSet()

	// 解析包名
	f, err := parser.ParseFile(fset, fileName, content, parser.ImportsOnly)
	if err != nil {
		return "", err
	}
	// 生成新的Run函数
	newRunFunc, _, paramsTypes := generateRunFunctionStr(fileName)
	// 构造完整的文件内容
	fileContent := runFileHeader
	fileContent += "package " + f.Name.Name + "\n\n"

	// 添加import内容
	fileContent += "import (\n"
	fileContent += "\t\"github.com/77d88/go-kit/basic/xerror\"\n"
	fileContent += "\t\"github.com/77d88/go-kit/plugins/x/servers/http/xhs\"\n"

	types := make([]string, 0, len(paramsTypes))
	for _, t := range paramsTypes {
		str := xstr.Replace(xstr.Split(t, ".")[0], "*", "")
		types = append(types, str)
	}
	types = xarray.Union(types)
	if len(types) > 0 {
		fileContent += "\t\"github.com/77d88/go-kit/plugins/x\"\n"
	}

	// 查询 paramsTypes 在  f.Imports中的引用并加入fileContent

	for _, t := range types {
		for _, importSpec := range f.Imports {
			if xstr.EndsWith(importSpec.Path.Value[1:len(importSpec.Path.Value)-1], t) {
				fileContent += "\t" + importSpec.Path.Value + "\n"
			}
		}
	}

	fileContent += ")\n"

	fileContent += newRunFunc
	return fileContent, nil
}

func UpdateRunFunc(fileName string) error {
	// 获取文件所在目录
	dir := filepath.Dir(fileName)

	file, err2 := os.ReadFile(fileName)
	if err2 != nil {
		return err2
	}

	// 如果是 runFileHeader 开头 则不处理
	if strings.HasPrefix(string(file), runFileHeader) {
		return nil
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return nil
	}
	b, _, _ := checkHandler(f)
	if !b {
		return nil
	}

	// 构造run.go文件路径
	runFileName := filepath.Join(dir, "run.go")

	// 读取文件内容
	content, err := os.ReadFile(runFileName)
	if err != nil {
		if os.IsNotExist(err) {
			return GenerateAndReplaceRunFunction(fileName)
		}
		return err
	}

	str, err := genRunFileContent(fileName)

	formatted, err := compareFuncFormatted(content, []byte(str), "run")
	if err != nil {
		return err
	}
	if formatted {
		return nil
	}

	// 不一致则更新文件
	return GenerateAndReplaceRunFunction(fileName)
}

// ScanAndGenerateRunFunctions 扫描文件夹下所有.go文件并生成Run函数
func ScanAndGenerateRunFunctions(dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 只处理.go文件，排除目录和非.go文件
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			// 检查文件是否包含handler函数
			if hasHandlerFunction(path) {
				err := UpdateRunFunc(path)
				if err != nil {
					return err
				}
			}
		}

		return nil
	})
}

// hasHandlerFunction 检查文件是否包含handler函数
func hasHandlerFunction(fileName string) bool {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil {
		return false
	}

	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == "handler" {
			// 检查参数数量，确保至少有2个参数(c和r)
			if len(funcDecl.Type.Params.List) >= 2 {
				return true
			}
		}
	}

	return false
}

// compareFuncFormatted 格式化后比较两个Run函数
func compareFuncFormatted(oldContent, newContent []byte, funcName string) (bool, error) {
	// 解析旧文件并提取Run函数
	fset1 := token.NewFileSet()
	oldFile, err := parser.ParseFile(fset1, "", oldContent, parser.ParseComments)
	if err != nil {
		return false, err
	}

	var oldFunc *ast.FuncDecl
	for _, decl := range oldFile.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == funcName {
			oldFunc = funcDecl
			break
		}
	}

	// 解析新文件并提取Run函数
	fset2 := token.NewFileSet()
	newFile, err := parser.ParseFile(fset2, "", newContent, parser.ParseComments)
	if err != nil {
		return false, err
	}

	var newFunc *ast.FuncDecl
	for _, decl := range newFile.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == funcName {
			newFunc = funcDecl
			break
		}
	}

	if oldFunc == nil || newFunc == nil {
		return oldFunc == newFunc, nil
	}

	// 格式化旧函数
	oldBuf := new(bytes.Buffer)
	err = format.Node(oldBuf, fset1, oldFunc)
	if err != nil {
		return false, err
	}

	// 格式化新函数
	newBuf := new(bytes.Buffer)
	err = format.Node(newBuf, fset2, newFunc)
	if err != nil {
		return false, err
	}

	// 比较格式化后的内容
	return bytes.Equal(oldBuf.Bytes(), newBuf.Bytes()), nil
}

func checkHandler(f *ast.File) (bool, *ast.FuncDecl, string) {
	const handlerName = "handler"
	var fn *ast.FuncDecl
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok && funcDecl.Name.Name == handlerName && len(funcDecl.Type.Params.List) >= 2 {
			fn = funcDecl
			break
		}
	}
	// 没有这个handler函数则不处理
	if fn == nil {
		return false, fn, ""
	}
	return fn.Name.Name == "handler" && checkHandlerReturnTypes(fn) && checkHandlerParamTypes(fn), fn, handlerName
}

// 检查返回值类型是否匹配
func checkHandlerReturnTypes(fn *ast.FuncDecl) bool {
	if len(fn.Type.Results.List) != 2 {
		return false
	}

	// 检查第一个返回值是否为 interface{}
	if _, ok := fn.Type.Results.List[0].Type.(*ast.InterfaceType); !ok {
		return false
	}

	// 检查第二个返回值是否为 error
	switch t := fn.Type.Results.List[1].Type.(type) {
	case *ast.Ident:
		if t.Name != "error" {
			return false
		}
	case *ast.SelectorExpr:
		if t.Sel.Name != "error" {
			return false
		}
	default:
		return false
	}

	return true
}

// 检查参数类型是否匹配
func checkHandlerParamTypes(fn *ast.FuncDecl) bool {
	if len(fn.Type.Params.List) < 2 {
		return false
	}

	// 检查第一个参数是否为 *xhs.Ctx
	if starExpr, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr); !ok {
		return false
	} else if selectorExpr, ok := starExpr.X.(*ast.SelectorExpr); !ok {
		return false
	} else if selectorExpr.Sel.Name != "Ctx" {
		return false
	}

	// 检查第二个参数是否为 *request
	if starExpr, ok := fn.Type.Params.List[1].Type.(*ast.StarExpr); !ok {
		return false
	} else if ident, ok := starExpr.X.(*ast.Ident); !ok {
		return false
	} else if ident.Name != "request" {
		return false
	}

	return true
}
